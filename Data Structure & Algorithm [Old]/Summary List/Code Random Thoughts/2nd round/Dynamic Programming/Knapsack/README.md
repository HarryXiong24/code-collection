# 0 - 1 背包理论

## 题目解析

有 n 件物品和一个最多能背重量为 w 的背包
第 i 件物品的重量是 weight[i]，得到的价值是 value[i]
每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大

eg: Let’s say you have a knapsack capacity of 5 and a list of items with weights and values as follows:
weights = [1, 2, 3, 5]
values = [10, 5, 4, 8]

```text
    weight
item 0 1 2 3 4 5
     1
     2
     3
     4
```

## dp 定义

dp[i][j] 是在前 i 个物品（0-i）中，满足重量 j 的最大价值总和

## 递推公式

如果在第 i 个物品的时候，我们不取 i，则：

```ts
dp[i][j] = dp[i - 1][j]; // 不取 i，则前 i-1 个物品中，满足重量 j 的最大价值总和
```

如果我们取 i，则：

```ts
dp[i][j] = dp[i - 1][j - weight[i]] + value[i];
// 取 i 就要留出 weight[i] 的重量，所以之前的重量一定要为 j - weight[i], 所以即为：则前 i-1 个物品中，满足重量 j - weight[i] 的最大价值总和 + 取当前 i 的价值 value[i]
// 注意 j - weight[i] >= 0 的时候才能取
```

最后两个结果要取 Max：

```ts
dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weights[i]] + values[i]);
```

## 一维的递推公式

dp[j] 表示不放物品 j 的状态

放 j:

```ts
dp[j - weight[i]] + value[i];
```

最后两个结果要取 Max：

```ts
dp[j] = Math.max(dp[j], dp[j - weights[i]] + values[i]);
```

其实相当于把二维数组中的 i 维度给移除了

### 一维的遍历顺序

```ts
for(int i = 0; i < weight.length; i++) { // 遍历物品
  for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
    dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
  }
}
```

二维 dp 遍历的时候，背包容量是从小到大，而一维 dp 遍历的时候，背包是从大到小。

为什么呢？

倒序遍历是为了保证物品 i 只被放入一次！。但如果一旦正序遍历了，那么物品 0 就会被重复加入多次！

举一个例子：物品 0 的重量 weight[0] = 1，价值 value[0] = 15

如果正序遍历

dp[1] = dp[1 - weight[0]] + value[0] = 15

dp[2] = dp[2 - weight[0]] + value[0] = 30

此时 dp[2]就已经是 30 了，意味着物品 0，被放入了两次，所以不能正序遍历。

为什么倒序遍历，就可以保证物品只放入一次呢？

倒序就是先算 dp[2]

dp[2] = dp[2 - weight[0]] + value[0] = 15 （dp 数组已经都初始化为 0）

dp[1] = dp[1 - weight[0]] + value[0] = 15

所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。

那么问题又来了，为什么二维 dp 数组遍历的时候不用倒序呢？

因为对于二维 dp，dp[i][j]都是通过上一层即 dp[i - 1][j]计算而来，本层的 dp[i][j]并不会被覆盖！

# 分割等和子集

## 题目解析

给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

输入: [1, 5, 11, 5]
输出: true
解释: 数组可以分割成 [1, 5, 5] 和 [11]

问题转化：

sum = 22

求数组中是否有子集元素和为 sum / 2。

可以看成背包的重量时 sum / 2，数组元素的重量为数组的值，价值也为重量。这就转化成了一个 0-1 背包问题。求是否能存在一个组合，他的重量能等于 sum / 2。

# 最后一块石头的重量 II

## 题目解析

有一堆石头，每块石头的重量都是正整数。

每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

如果 x == y，那么两块石头都会被完全粉碎；

如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。

最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。

示例：

输入：[2,7,4,1,8,1]
输出：1
解释：

组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。

## 问题转化

其实这个问题就是，尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小，这样就化解成 0-1 背包问题了。

可以看成背包的重量为 Math.floor(sum / 2)，数组元素的重量为数组的值，价值也为重量。
dp[i][j] 的含义是：在前 i 个数组元素中，有一个重量为 j 的背包，最多可以背的最大重量（原来是价值，这里价值就是重量）

如果是一维数组的话，dp[j] 的含义是：

dp[j]表示容量（这里说容量更形象，其实就是重量）为 j 的背包，最多可以背最大重量为 dp[j]。

# 目标和

## 题目解析

给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

示例：

输入：nums: [1, 1, 1, 1, 1], S: 3
输出：5

解释：

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3
一共有 5 种方法让最终目标和为 3。

## 题目转化

也列出关系：

let 1 value is the left subset, -1 value is the right subset
left + right = sum
left - right = target
=> left = (sum + target) / 2

所以只需要求 left 即可：

target 3, sum = 5
left => 4
if (sum + target) % 2 != 0, no result

这里就转化成了一个背包问题：

有 i 个元素，每个的价值为 1，背包的重量为 (sum + target) / 2，求背包装满的最大有多少种组合

因此 dp 定义：

dp[i][j]：使用下标为[0, i] 的 nums[i] 能够凑满 j（包括 j）这么大容量的包，有 dp[i][j]种方法。

递推公式

```ts
for (let i: number = 0; i < nums.length; i++) {
  for (let j: number = left; j >= nums[i]; j--) {
    dp[j] += dp[j - nums[i]];
  }
}
```

# 一和零

## 题目解析

给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。

如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

示例 1：

输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3

输出：4

解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。 其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。

示例 2：

输入：strs = ["10", "0", "1"], m = 1, n = 1
输出：2
解释：最大的子集是 {"0", "1"} ，所以答案是 2 。

## 题目分析

多重背包是每个物品，数量不同的情况。

本题中 strs 数组里的元素就是物品，每个物品都是一个！

而 m 和 n 相当于是一个背包，两个维度的背包。

dp[i][j][k]: 前 i 个物品中, 背包的 0 容量为 j, 1 容量为 k, 最多能放的物品数量

## 递推公式

```ts
for (let i = 1; i < dp.length; i++) {
  const { numOfZero, numOfOne } = countBinary(strs[i]);
  for (let j = 0; j < dp[i].length; j++) {
    for (let k = 0; k < dp[i][j].length; k++) {
      if (j - numOfZero < 0 || k - numOfOne < 0) {
        dp[i][j][k] = dp[i - 1][j][k];
      } else {
        dp[i][j][k] = Math.max(dp[i - 1][j][k], dp[i - 1][j - numOfZero][k - numOfOne] + 1);
      }
    }
  }
}
```

# 完全背包

如果求组合数就是外层 for 循环遍历物品，内层 for 遍历背包。

如果求排列数就是外层 for 遍历背包，内层 for 循环遍历物品。
