# 0 - 1 背包理论

## 题目解析

有 n 件物品和一个最多能背重量为 w 的背包
第 i 件物品的重量是 weight[i]，得到的价值是 value[i]
每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大

eg: Let’s say you have a knapsack capacity of 5 and a list of items with weights and values as follows:
weights = [1, 2, 3, 5]
values = [10, 5, 4, 8]

```text
    weight
item 0 1 2 3 4 5
     1
     2
     3
     4
```

## dp 定义

dp[i][j] 是在前 i 个物品（0-i）中，满足重量 j 的最大价值总和

## 递推公式

如果在第 i 个物品的时候，我们不取 i，则：

```ts
dp[i][j] = dp[i - 1][j]; // 不取 i，则前 i-1 个物品中，满足重量 j 的最大价值总和
```

如果我们取 i，则：

```ts
dp[i][j] = dp[i - 1][j - weight[i]] + value[i];
// 取 i 就要留出 weight[i] 的重量，所以之前的重量一定要为 j - weight[i], 所以即为：则前 i-1 个物品中，满足重量 j - weight[i] 的最大价值总和 + 取当前 i 的价值 value[i]
// 注意 j - weight[i] >= 0 的时候才能取
```

最后两个结果要取 Max：

```ts
dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weights[i]] + values[i]);
```

## 一维的递推公式

dp[j] 表示不放物品 j 的状态

放 j:

```ts
dp[j - weight[i]] + value[i];
```

最后两个结果要取 Max：

```ts
dp[j] = Math.max(dp[j], dp[j - weights[i]] + values[i]);
```

其实相当于把二维数组中的 i 维度给移除了

### 一维的遍历顺序

```ts
for(int i = 0; i < weight.length; i++) { // 遍历物品
  for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
    dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
  }
}
```

二维 dp 遍历的时候，背包容量是从小到大，而一维 dp 遍历的时候，背包是从大到小。

为什么呢？

倒序遍历是为了保证物品 i 只被放入一次！。但如果一旦正序遍历了，那么物品 0 就会被重复加入多次！

举一个例子：物品 0 的重量 weight[0] = 1，价值 value[0] = 15

如果正序遍历

dp[1] = dp[1 - weight[0]] + value[0] = 15

dp[2] = dp[2 - weight[0]] + value[0] = 30

此时 dp[2]就已经是 30 了，意味着物品 0，被放入了两次，所以不能正序遍历。

为什么倒序遍历，就可以保证物品只放入一次呢？

倒序就是先算 dp[2]

dp[2] = dp[2 - weight[0]] + value[0] = 15 （dp 数组已经都初始化为 0）

dp[1] = dp[1 - weight[0]] + value[0] = 15

所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。

那么问题又来了，为什么二维 dp 数组遍历的时候不用倒序呢？

因为对于二维 dp，dp[i][j]都是通过上一层即 dp[i - 1][j]计算而来，本层的 dp[i][j]并不会被覆盖！

# 分割等和子集

## 题目解析

给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

输入: [1, 5, 11, 5]
输出: true
解释: 数组可以分割成 [1, 5, 5] 和 [11]

问题转化：

sum = 22

求数组中是否有子集元素和为 sum / 2。

可以看成背包的重量时 sum / 2，数组元素的重量为数组的值，价值也为重量。这就转化成了一个 0-1 背包问题。求是否能存在一个组合，他的重量能等于 sum / 2。

# 最后一块石头的重量 II

## 题目解析

有一堆石头，每块石头的重量都是正整数。

每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

如果 x == y，那么两块石头都会被完全粉碎；

如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。

最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。

示例：

输入：[2,7,4,1,8,1]
输出：1
解释：

组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。

## 问题转化

其实这个问题就是，尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小，这样就化解成 0-1 背包问题了。

可以看成背包的重量为 Math.floor(sum / 2)，数组元素的重量为数组的值，价值也为重量。
dp[i][j] 的含义是：在前 i 个数组元素中，有一个重量为 j 的背包，最多可以背的最大重量（原来是价值，这里价值就是重量）

如果是一维数组的话，dp[j] 的含义是：

dp[j]表示容量（这里说容量更形象，其实就是重量）为 j 的背包，最多可以背最大重量为 dp[j]。

# 目标和

## 题目解析

给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

示例：

输入：nums: [1, 1, 1, 1, 1], S: 3
输出：5

解释：

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3
一共有 5 种方法让最终目标和为 3。

## 题目转化

也列出关系：

let 1 value is the left subset, -1 value is the right subset
left + right = sum
left - right = target
=> left = (sum + target) / 2

所以只需要求 left 即可：

target 3, sum = 5
left => 4
if (sum + target) % 2 != 0, no result

这里就转化成了一个背包问题：

有 i 个元素，每个的价值为 1，背包的重量为 (sum + target) / 2，求背包装满的最大有多少种组合

因此 dp 定义：

dp[i][j]：使用下标为[0, i] 的 nums[i] 能够凑满 j（包括 j）这么大容量的包，有 dp[i][j]种方法。
